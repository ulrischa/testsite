<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sortable Web Component (Mobil unterst체tzt)</title>
</head>
<body>
  <!-- Verwendung der Web Component -->
  <sortable-container>
    <div>Item 1</div>
    <div>Item 2</div>
    <div>Item 3</div>
  </sortable-container>

  <script>
    class SortableContainer extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: 'open' });

        // HTML-Template f체r die Web Component
        this.shadowRoot.innerHTML = `
          <style>
            :host {
              display: block;
            }
            .sortable-container {
              display: flex;
              flex-direction: column;
              gap: 0.5rem;
            }
            .sortable-item {
              padding: 1rem;
              border: 1px solid #ccc;
              background-color: #f9f9f9;
              cursor: grab;
              user-select: none;
              transition: transform 0.2s;
            }
            .sortable-item.dragging {
              opacity: 0.5;
              background-color: #e0e0e0;
            }
          </style>
          <div class="sortable-container">
            <slot></slot>
          </div>
        `;

        this.sortableContainer = this.shadowRoot.querySelector('.sortable-container');
        this.draggedItem = null;
        this.touchStartY = 0;
        this.touchEndY = 0;
      }

      connectedCallback() {
        this._initSortableItems();
      }

      _initSortableItems() {
        const slot = this.shadowRoot.querySelector('slot');
        slot.addEventListener('slotchange', () => {
          const items = slot.assignedElements().filter(el => el.tagName !== 'STYLE');

          items.forEach(item => {
            item.classList.add('sortable-item');

            // Drag-and-Drop Events
            item.draggable = true;
            item.addEventListener('dragstart', (e) => this._onDragStart(e, item));
            item.addEventListener('dragover', (e) => this._onDragOver(e));
            item.addEventListener('dragend', () => this._onDragEnd(item));
            item.addEventListener('drop', (e) => this._onDrop(e, item));

            // Touch Events f체r mobile Ger채te
            item.addEventListener('touchstart', (e) => this._onTouchStart(e, item));
            item.addEventListener('touchmove', (e) => this._onTouchMove(e, item));
            item.addEventListener('touchend', () => this._onTouchEnd(item));
          });
        });
      }

      // Drag-and-Drop Handlers
      _onDragStart(event, item) {
        this.draggedItem = item;
        item.classList.add('dragging');
        event.dataTransfer.effectAllowed = 'move';
      }

      _onDragOver(event) {
        event.preventDefault();
      }

      _onDrop(event, targetItem) {
        event.preventDefault();
        this._moveItem(this.draggedItem, targetItem);
      }

      _onDragEnd(item) {
        item.classList.remove('dragging');
        this.draggedItem = null;
      }

      // Touch Event Handlers (Mobil)
      _onTouchStart(event, item) {
        this.draggedItem = item;
        this.touchStartY = event.touches[0].clientY;
        item.classList.add('dragging');
      }

      _onTouchMove(event, item) {
        this.touchEndY = event.touches[0].clientY;
        const targetItem = this._getClosestElement(item, this.touchEndY);
        if (targetItem && targetItem !== this.draggedItem) {
          this._moveItem(this.draggedItem, targetItem);
        }
      }

      _onTouchEnd(item) {
        item.classList.remove('dragging');
        this.draggedItem = null;
      }

      // Hilfsfunktionen
      _moveItem(draggedItem, targetItem) {
        const container = this.sortableContainer;
        const items = [...this.children];
        const draggedIndex = items.indexOf(draggedItem);
        const targetIndex = items.indexOf(targetItem);

        if (draggedIndex > targetIndex) {
          container.insertBefore(draggedItem, targetItem);
        } else {
          container.insertBefore(draggedItem, targetItem.nextSibling);
        }

        this._updateDataModel();
      }

      _getClosestElement(draggedItem, touchY) {
        const items = [...this.children];
        return items.reduce((closest, child) => {
          if (child !== draggedItem) {
            const box = child.getBoundingClientRect();
            const offset = Math.abs(touchY - (box.top + box.height / 2));
            if (offset < closest.offset) {
              return { offset, element: child };
            }
          }
          return closest;
        }, { offset: Number.POSITIVE_INFINITY }).element;
      }

      _updateDataModel() {
        const slot = this.shadowRoot.querySelector('slot');
        const sortedItems = slot.assignedElements().filter(el => el.tagName !== 'STYLE');

        this.dispatchEvent(new CustomEvent('sort', {
          detail: sortedItems.map(item => item.textContent)
        }));
      }
    }

    customElements.define('sortable-container', SortableContainer);
  </script>
</body>
</html>
