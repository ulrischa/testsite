<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Flüssiges Drag-and-Drop für Mobile und Desktop</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <!-- Sortable List -->
  <sortable-list>
    <div>Element 1</div>
    <div>Element 2</div>
    <div>Element 3</div>
    <div>Element 4</div>
  </sortable-list>

  <script>
    class SortableList extends HTMLElement {
      items = [];
      draggedItem = null;
      startY = 0;
      currentY = 0;
      placeholder = null;

      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.initializeItems();
        this.render();
      }

      initializeItems() {
        this.items = Array.from(this.children);
      }

      render() {
        this.shadowRoot.innerHTML = `
          <style>
            ::slotted(*) {
              padding: 10px;
              margin: 4px 0;
              background: #f3f3f3;
              border: 1px solid #ccc;
              border-radius: 4px;
              cursor: move;
              user-select: none;
              transition: transform 0.1s ease;
            }
            .dragging {
              opacity: 0.7;
              z-index: 1000;
              position: absolute;
              pointer-events: none;
              box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            }
            .placeholder {
              background: #ddd;
              border: 1px dashed #aaa;
              height: 40px;
              margin: 4px 0;
            }
          </style>
          <slot></slot>
        `;

        this.addEventListeners();
      }

      addEventListeners() {
        this.items.forEach((item) => {
          item.draggable = true;

          // Desktop-Drag-and-Drop
          item.addEventListener("dragstart", (e) => this.onDragStart(e, item));
          item.addEventListener("dragover", (e) => e.preventDefault());
          item.addEventListener("drop", (e) => this.onDrop(item));

          // Mobile-Touch-Events
          item.addEventListener("touchstart", (e) => this.onTouchStart(e, item));
          item.addEventListener("touchmove", (e) => this.onTouchMove(e));
          item.addEventListener("touchend", () => this.onTouchEnd());
        });
      }

      createPlaceholder(height) {
        const placeholder = document.createElement("div");
        placeholder.classList.add("placeholder");
        placeholder.style.height = `${height}px`;
        return placeholder;
      }

      onDragStart(event, item) {
        this.draggedItem = item;
        item.classList.add("dragging");
        this.placeholder = this.createPlaceholder(item.offsetHeight);
        item.parentNode.insertBefore(this.placeholder, item.nextSibling);
      }

      onDrop(target) {
        if (this.draggedItem && this.placeholder) {
          target.parentNode.insertBefore(this.draggedItem, this.placeholder);
          this.cleanup();
        }
      }

      onTouchStart(event, item) {
        this.draggedItem = item;
        this.startY = event.touches[0].clientY;

        // Temporäre visuelle Änderungen
        item.classList.add("dragging");
        item.style.transition = "none";

        // Platzhalter erstellen
        this.placeholder = this.createPlaceholder(item.offsetHeight);
        item.parentNode.insertBefore(this.placeholder, item.nextSibling);
      }

      onTouchMove(event) {
        if (!this.draggedItem) return;

        event.preventDefault();
        this.currentY = event.touches[0].clientY;
        const deltaY = this.currentY - this.startY;

        // Element visuell bewegen
        this.draggedItem.style.transform = `translate3d(0, ${deltaY}px, 0)`;

        // Zielposition bestimmen
        const rect = this.placeholder.getBoundingClientRect();
        if (this.currentY > rect.bottom) {
          this.placeholder.parentNode.insertBefore(this.placeholder, this.placeholder.nextSibling.nextSibling);
        } else if (this.currentY < rect.top) {
          this.placeholder.parentNode.insertBefore(this.placeholder, this.placeholder.previousSibling);
        }
      }

      onTouchEnd() {
        if (this.draggedItem && this.placeholder) {
          this.placeholder.parentNode.insertBefore(this.draggedItem, this.placeholder);
          this.cleanup();
        }
      }

      cleanup() {
        this.draggedItem.style.transform = "";
        this.draggedItem.style.transition = "";
        this.draggedItem.classList.remove("dragging");
        this.placeholder.remove();
        this.placeholder = null;
        this.draggedItem = null;
      }
    }

    customElements.define("sortable-list", SortableList);
  </script>
</body>
</html>
