<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Sortable Webcomponent</title>
<style>
  body {
    font-family: sans-serif;
    margin: 20px;
  }
  .example-container {
    width: 300px;
    margin: 0 auto;
  }
</style>
</head>
<body>
<div class="example-container">
  <h1>Sortable Items</h1>
  <!-- Beispielinstanz der Webkomponente mit direkt eingefügten Einträgen -->
  <sortable-list>
    <div>Eintrag A</div>
    <div>Eintrag B</div>
    <div>Eintrag C</div>
    <div>Eintrag D</div>
    <div>Eintrag E</div>
  </sortable-list>
</div>

<script>
/**
 * Polyfill für Drag & Drop auf mobilen Geräten.
 * Dieser Code fügt Touch-Events hinzu, um Drag & Drop auf Touch-Geräten zu simulieren.
 */
(function () {
  // Prüfe ob Touch vorhanden ist, aber kein natives Drag & Drop unterstützt wird
  if ('ontouchstart' in window && !('draggable' in document.createElement('span'))) {
    let dragSrcEl = null;
    let currentlyDragging = false;
    let clonedEl = null;
    let offsetX = 0;
    let offsetY = 0;

    document.addEventListener('touchstart', function(e) {
      const target = e.target.closest('[draggable="true"]');
      if (!target) return;
      dragSrcEl = target;
      currentlyDragging = false;
      const rect = target.getBoundingClientRect();
      const touch = e.touches[0];
      offsetX = touch.clientX - rect.left;
      offsetY = touch.clientY - rect.top;
    }, {passive: false});

    document.addEventListener('touchmove', function(e) {
      if (!dragSrcEl) return;
      e.preventDefault();
      if (!currentlyDragging) {
        // Dragstart simulieren
        let dragStartEvent = new Event('dragstart', {bubbles: true, cancelable: true});
        dragSrcEl.dispatchEvent(dragStartEvent);
        currentlyDragging = true;
        // Visuelles Feedback
        clonedEl = dragSrcEl.cloneNode(true);
        clonedEl.style.position = 'fixed';
        clonedEl.style.pointerEvents = 'none';
        clonedEl.style.opacity = '0.8';
        clonedEl.style.top = '-9999px';
        clonedEl.style.left = '-9999px';
        clonedEl.style.width = dragSrcEl.getBoundingClientRect().width + 'px';
        clonedEl.style.zIndex = '9999';
        document.body.appendChild(clonedEl);
      }
      const touch = e.touches[0];
      if (clonedEl) {
        clonedEl.style.left = (touch.clientX - offsetX) + 'px';
        clonedEl.style.top = (touch.clientY - offsetY) + 'px';
      }
      // Dragover simulieren
      let dragOverEvent = new Event('dragover', {bubbles: true, cancelable: true});
      let target = document.elementFromPoint(touch.clientX, touch.clientY);
      if (target) {
        target.dispatchEvent(dragOverEvent);
      }
    }, {passive: false});

    document.addEventListener('touchend', function(e) {
      if (currentlyDragging && dragSrcEl) {
        const touch = e.changedTouches[0];
        let dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);
        if (dropTarget) {
          let dragEndEvent = new Event('dragend', {bubbles: true, cancelable: true});
          dragSrcEl.dispatchEvent(dragEndEvent);
          let dropEvent = new Event('drop', {bubbles: true, cancelable: true});
          dropTarget.dispatchEvent(dropEvent);
        }
      }
      if (clonedEl && clonedEl.parentNode) {
        clonedEl.parentNode.removeChild(clonedEl);
      }
      dragSrcEl = null;
      clonedEl = null;
      currentlyDragging = false;
    }, {passive: false});
  }
})();
</script>

<script>
/**
 * WebComponent <sortable-list>:
 * Ermöglicht Drag & Drop Sortierung der enthaltenen Child-Elemente.
 * - Die Items werden beim Laden aus dem Light-DOM gelesen und intern als Array gehalten.
 * - Anschließend wird das Light-DOM geleert und die Darstellung erfolgt ausschließlich über Shadow-DOM (gerendert aus dem State).
 * - Änderungen durch Drag & Drop führen zu einem Neurendern.
 * - Für mobile Geräte ist ein Polyfill integriert.
 * - Kein direktes Manipulieren einzelner DOM-Knoten, sondern komplettes Neu-Rendern bei Änderungen (ähnlich wie React).
 */

class SortableList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.items = [];
    this.draggedIndex = null;
    this.dropIndex = null;
  }

  connectedCallback() {
    const elementNodes = Array.from(this.children).filter(n => n.nodeType === Node.ELEMENT_NODE);
    // Nur den inneren Inhalt sichern, um doppeltes Verschachteln zu vermeiden.
    this.items = elementNodes.map(el => el.innerHTML);
    // Light DOM leeren
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }
    this.render();
  }

  setItems(newItems) {
    this.items = newItems;
    this.render();
  }

  handleDragStart(e, index) {
    e.stopPropagation();
    e.dataTransfer.effectAllowed = 'move';
    // Mindestens ein Datentyp setzen, sonst kann Drag & Drop fehlschlagen
    e.dataTransfer.setData('text/plain', String(index));
    this.draggedIndex = index;
    this.render();
  }

  handleDragOver(e, index) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    if (index !== this.dropIndex) {
      this.dropIndex = index;
      this.render();
    }
  }

  handleDrop(e, index) {
    e.preventDefault();
    const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
    const toIndex = (typeof index === 'number' && index >= 0) ? index : this.items.length;
    this.moveItem(fromIndex, toIndex);
    this.draggedIndex = null;
    this.dropIndex = null;
    this.render();
  }

  handleDragEnd() {
    this.draggedIndex = null;
    this.dropIndex = null;
    this.render();
  }

  moveItem(fromIndex, toIndex) {
    if (fromIndex === toIndex) return;
    const newItems = [...this.items];
    const [moved] = newItems.splice(fromIndex, 1);
    if (toIndex > newItems.length) {
      newItems.push(moved);
    } else {
      newItems.splice(toIndex, 0, moved);
    }
    this.setItems(newItems);
  }

  template() {
    const styles = `
      :host {
        display: block;
        border: 1px solid #ccc;
        border-radius: 4px;
        background: #f9f9f9;
        padding: 0;
        user-select: none;
      }
      .list-container {
        display: block;
      }
      .list-item {
        padding: 10px;
        background: #fff;
        border-bottom: 1px solid #ddd;
        cursor: move;
        transition: background 0.2s;
      }
      .list-item:last-child {
        border-bottom: none;
      }
      .list-item.dragging {
        opacity: 0.6;
        background: #e0e0e0;
      }
      .placeholder {
        height: 40px;
        background: #f0faff;
        border: 2px dashed #2196f3;
        margin-bottom: 5px;
      }
      .list-item:hover {
        background: #f5f5f5;
      }
    `;

    const children = [];
    // Platzhalter-Logik und Items rendern
    this.items.forEach((item, i) => {
      const isDragged = (i === this.draggedIndex);

      // Platzhalter vor Item einfügen, falls nötig
      if (this.dropIndex !== null && this.dropIndex === i && this.dropIndex !== this.draggedIndex) {
        children.push(`<div class="placeholder"></div>`);
      }

      children.push(`
        <div 
          class="list-item ${isDragged ? 'dragging' : ''}"
          draggable="true"
          data-index="${i}"
        >${item}</div>
      `);
    });

    // Platzhalter am Ende, falls dropIndex == items.length
    if (this.dropIndex !== null && this.dropIndex === this.items.length && this.draggedIndex !== this.dropIndex) {
      children.push(`<div class="placeholder"></div>`);
    }

    return `
      <style>${styles}</style>
      <div class="list-container">
        ${children.join('')}
      </div>
    `;
  }

  addEventListeners() {
    const container = this.shadowRoot.querySelector('.list-container');
    if (!container) return;

    const itemEls = container.querySelectorAll('.list-item');
    itemEls.forEach((el) => {
      const index = parseInt(el.getAttribute('data-index'), 10);

      el.addEventListener('dragstart', (e) => {
        this.handleDragStart(e, index);
      });
      el.addEventListener('dragover', (e) => {
        this.handleDragOver(e, index);
      });
      el.addEventListener('drop', (e) => {
        this.handleDrop(e, index);
      });
      el.addEventListener('dragend', () => {
        this.handleDragEnd();
      });
    });

    // Erlaube Drop am Ende, wenn unter das letzte Element gezogen
    container.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (this.draggedIndex !== null) {
        const y = e.clientY;
        let lastItem = container.querySelector('.list-item:last-child');
        if (lastItem) {
          const lastItemRect = lastItem.getBoundingClientRect();
          if (y > lastItemRect.bottom && this.dropIndex !== this.items.length) {
            this.dropIndex = this.items.length;
            this.render();
          }
        } else {
          // Keine Items vorhanden
          if (this.items.length === 0 && this.dropIndex !== 0) {
            this.dropIndex = 0;
            this.render();
          }
        }
      }
    });

    container.addEventListener('drop', (e) => {
      e.preventDefault();
      if (this.draggedIndex !== null && this.dropIndex !== null) {
        this.handleDrop(e, this.dropIndex);
      }
    });

    container.addEventListener('dragend', () => {
      this.handleDragEnd();
    });
  }

  render() {
    this.shadowRoot.innerHTML = this.template();
    this.addEventListeners();
  }
}

customElements.define('sortable-list', SortableList);
</script>
</body>
</html>
