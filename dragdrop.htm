<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Datengetriebenes Drag-and-Drop für Mobile und Desktop</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }
  </style>
</head>
<body>
  <sortable-list>
    <div>Element 1</div>
    <div>Element 2</div>
    <div>Element 3</div>
    <div>Element 4</div>
  </sortable-list>

  <script>
    class SortableList extends HTMLElement {
      items = [];       // Datenquelle: enthält die Reihenfolge der Elemente
      draggedIndex = null; // Index des aktuell gezogenen Elements
      startY = 0;       // Startposition bei Touch

      constructor() {
        super();
        this.attachShadow({ mode: 'open' });
      }

      connectedCallback() {
        this.initializeItems();
        this.render();
      }

      /** Initialisiere die Datenquelle mit den Slotted Inhalten */
      initializeItems() {
        this.items = Array.from(this.children).map((child) => child.outerHTML.trim());
      }

      /** Rendert die Liste basierend auf der Datenquelle */
      render() {
        this.shadowRoot.innerHTML = `
          <style>
            .item {
              padding: 10px;
              margin: 4px 0;
              background: #f3f3f3;
              border: 1px solid #ccc;
              border-radius: 4px;
              cursor: move;
              user-select: none;
              transition: transform 0.1s ease;
            }
            .dragging {
              opacity: 0.7;
            }
          </style>
          ${this.items.map((content, index) => `
            <div class="item" draggable="true" data-index="${index}">
              ${content}
            </div>
          `).join('')}
        `;

        this.addEventListeners();
      }

      /** Fügt Drag-and-Drop und Touch-Event-Handler hinzu */
      addEventListeners() {
        const items = this.shadowRoot.querySelectorAll('.item');

        items.forEach((item) => {
          // Desktop Drag-and-Drop Events
          item.addEventListener('dragstart', (e) => this.onDragStart(e, item));
          item.addEventListener('dragover', (e) => e.preventDefault());
          item.addEventListener('drop', (e) => this.onDrop(e, item));

          // Touch Events
          item.addEventListener('touchstart', (e) => this.onTouchStart(e, item));
          item.addEventListener('touchmove', (e) => this.onTouchMove(e, item));
          item.addEventListener('touchend', () => this.onTouchEnd());
        });
      }

      /** Dragstart: Speichert den Index des gezogenen Elements */
      onDragStart(event, item) {
        this.draggedIndex = parseInt(item.dataset.index);
        item.classList.add('dragging');
      }

      /** Drop: Aktualisiert die Reihenfolge in der Datenquelle */
      onDrop(event, targetItem) {
        const targetIndex = parseInt(targetItem.dataset.index);
        this.swapItems(this.draggedIndex, targetIndex);
        this.render();
      }

      /** Touchstart: Speichert den Startpunkt */
      onTouchStart(event, item) {
        this.draggedIndex = parseInt(item.dataset.index);
        this.startY = event.touches[0].clientY;
        item.classList.add('dragging');
      }

      /** Touchmove: Simuliert die visuelle Bewegung */
      onTouchMove(event, item) {
        const deltaY = event.touches[0].clientY - this.startY;
        item.style.transform = `translate3d(0, ${deltaY}px, 0)`;
      }

      /** Touchend: Aktualisiert die Reihenfolge */
      onTouchEnd() {
        this.items = this.items.sort((a, b) => {
          return a.includes('dragging') ? 1 : -1;
        });
        this.render();
      }

      /** Tauscht zwei Elemente in der Datenquelle */
      swapItems(fromIndex, toIndex) {
        [this.items[fromIndex], this.items[toIndex]] = [this.items[toIndex], this.items[fromIndex]];
      }
    }

    customElements.define('sortable-list', SortableList);
  </script>
</body>
</html>
