<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sortable Webcomponent</title>
</head>
<body>

<script>
// --- Touch Drag & Drop Polyfill (einfacher Ansatz) ---
// Simpler Polyfill für Drag & Drop auf Touch-Geräten.
// Dies ist kein vollwertiger Produktivcode, sondern dient nur der Demonstration.
(function() {
  const isTouchDevice = 'ontouchstart' in window;
  if (!isTouchDevice) return;

  let draggedEl = null;
  let currentDropTarget = null;

  document.addEventListener('touchstart', (e) => {
    const target = e.target.closest('[draggable="true"]');
    if (target) {
      draggedEl = target;
      target.classList.add('dragging');
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchmove', (e) => {
    if (draggedEl) {
      const elem = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
      if (elem) {
        let dropTarget = elem.closest('[draggable="true"]');
        if (dropTarget && dropTarget !== draggedEl) {
          currentDropTarget = dropTarget;
        }
      }
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchend', (e) => {
    if (draggedEl) {
      draggedEl.classList.remove('dragging');
      if (currentDropTarget && currentDropTarget.parentNode) {
        const dropEvent = new Event('drop', {bubbles: true});
        dropEvent.dataTransfer = {
          getData: () => draggedEl.getAttribute('data-id')
        };
        currentDropTarget.dispatchEvent(dropEvent);
      }
      draggedEl = null;
      currentDropTarget = null;
      e.preventDefault();
    }
  }, {passive:false});
})();

// --- Custom Element ---
class SortableList extends HTMLElement {
  static get template() {
    return `
      <style>
        :host {
          display: block;
          border: 1px solid #ccc;
          padding: 0.5rem;
          background: #ffffff;
          font-family: sans-serif;
        }
        .sortable-item {
          user-select: none;
          background: #f9f9f9;
          margin: 0.25rem 0;
          padding: 0.5rem;
          border: 1px solid #ddd;
          border-radius: 4px;
          cursor: move;
          transition: background 0.2s, opacity 0.2s;
          display: block;
        }
        .sortable-item.dragging {
          opacity: 0.5;
          background: #ffe5b4;
        }
        .drop-indicator {
          height: 0;
          border-top: 2px dashed #888;
          margin: 0.4rem 0;
        }
        #container {
          display: block;
        }
      </style>
      <div id="container"></div>
    `;
  }

  constructor() {
    super();
    this.attachShadow({mode: 'open'});
    this.items = [];
    this.draggedItemId = null;
    this.dragOverIndex = null;

    this.onDragStart = this.onDragStart.bind(this);
    this.onDragEnd   = this.onDragEnd.bind(this);
    this.onDragEnter = this.onDragEnter.bind(this);
    this.onDragOver  = this.onDragOver.bind(this);
    this.onDragLeave = this.onDragLeave.bind(this);
    this.onDrop      = this.onDrop.bind(this);
  }

  connectedCallback() {
    // Kind-Elemente des Light-DOM ermitteln, bevor wir sie entfernen
    const children = Array.from(this.children).filter(el => el.nodeType === Node.ELEMENT_NODE);
    this.items = children.map((child, index) => ({
      id: String(index),
      content: child.innerHTML.trim()
    }));

    // Light DOM leeren
    this.innerHTML = '';

    // Rendern
    this.render();

    // Event Listener im Shadow DOM
    this.shadowRoot.addEventListener('dragstart', this.onDragStart);
    this.shadowRoot.addEventListener('dragenter', this.onDragEnter);
    this.shadowRoot.addEventListener('dragover', this.onDragOver);
    this.shadowRoot.addEventListener('dragleave', this.onDragLeave);
    this.shadowRoot.addEventListener('drop', this.onDrop);
    this.shadowRoot.addEventListener('dragend', this.onDragEnd);
  }

  indexOfItem(id) {
    return this.items.findIndex(i => i.id === id);
  }

  onDragStart(e) {
    const target = e.target.closest('.sortable-item');
    if (!target) return;
    this.draggedItemId = target.getAttribute('data-id');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text', this.draggedItemId);
    this.render();
  }

  onDragEnter(e) {
    e.preventDefault();
  }

  onDragOver(e) {
    e.preventDefault();
    const target = e.target.closest('.sortable-item');
    if (!target || target.getAttribute('data-id') === this.draggedItemId) return;

    const bounding = target.getBoundingClientRect();
    const offset = e.clientY - bounding.top;
    const isAfter = offset > bounding.height / 2;
    const targetIndex = this.indexOfItem(target.getAttribute('data-id'));
    this.dragOverIndex = isAfter ? targetIndex + 1 : targetIndex;

    this.render();
  }

  onDragLeave(e) {
    // Prüfen ob wir das gesamte Shadow DOM verlassen haben
    if (!e.relatedTarget || !this.shadowRoot.contains(e.relatedTarget)) {
      this.dragOverIndex = null;
      this.render();
    }
  }

  onDrop(e) {
    e.stopPropagation();
    const draggedId = e.dataTransfer.getData('text');
    const fromIndex = this.indexOfItem(draggedId);
    let toIndex = this.dragOverIndex !== null ? this.dragOverIndex : this.items.length;

    if (toIndex > this.items.length) toIndex = this.items.length;
    if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {
      const [moved] = this.items.splice(fromIndex, 1);
      this.items.splice(toIndex, 0, moved);
    }

    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  onDragEnd() {
    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  render() {
    let html = this.constructor.template;
    let itemsHtml = '';

    this.items.forEach((item, index) => {
      if (this.dragOverIndex === index) {
        itemsHtml += `<div class="drop-indicator"></div>`;
      }
      const draggingClass = (this.draggedItemId === item.id) ? ' dragging' : '';
      itemsHtml += `<div class="sortable-item${draggingClass}" draggable="true" data-id="${item.id}">${item.content}</div>`;
    });

    if (this.dragOverIndex === this.items.length) {
      itemsHtml += `<div class="drop-indicator"></div>`;
    }

    html = html.replace('<div id="container"></div>', `<div id="container">${itemsHtml}</div>`);

    this.shadowRoot.innerHTML = html;
  }
}

customElements.define('sortable-list', SortableList);
</script>

<!-- Beispiel-Nutzung -->
<sortable-list>
  <div>Element A</div>
  <div>Element B</div>
  <div>Element C</div>
  <div>Element D</div>
</sortable-list>

</body>
</html>
