<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sortable Webcomponent</title>
</head>
<body>

<script>
// --- Touch Drag & Drop Polyfill (einfacher Ansatz) ---
// Simpler Polyfill für Drag & Drop auf Touch-Geräten.
// Dies ist kein vollwertiger Produktivcode, sondern dient nur der Demonstration.
(function() {
  const isTouchDevice = 'ontouchstart' in window;
  if (!isTouchDevice) return;

  let draggedEl = null;
  let currentDropTarget = null;

  document.addEventListener('touchstart', (e) => {
    const target = e.target.closest('[draggable="true"]');
    if (target) {
      draggedEl = target;
      target.classList.add('dragging');
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchmove', (e) => {
    if (draggedEl) {
      const elem = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
      if (elem) {
        let dropTarget = elem.closest('[draggable="true"]');
        if (dropTarget && dropTarget !== draggedEl) {
          currentDropTarget = dropTarget;
        }
      }
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchend', (e) => {
    if (draggedEl) {
      draggedEl.classList.remove('dragging');
      if (currentDropTarget && currentDropTarget.parentNode) {
        const dropEvent = new Event('drop', {bubbles: true});
        dropEvent.dataTransfer = {
          getData: () => draggedEl.getAttribute('data-id')
        };
        currentDropTarget.dispatchEvent(dropEvent);
      }
      draggedEl = null;
      currentDropTarget = null;
      e.preventDefault();
    }
  }, {passive:false});
})();

// --- Custom Element ---
class SortableList extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({mode: 'open'});
    this.items = [];
    this.draggedItemId = null;
    this.dragOverIndex = null;

    // Event-Bindings
    this.onDragStart = this.onDragStart.bind(this);
    this.onDragEnd   = this.onDragEnd.bind(this);
    this.onDragEnter = this.onDragEnter.bind(this);
    this.onDragOver  = this.onDragOver.bind(this);
    this.onDragLeave = this.onDragLeave.bind(this);
    this.onDrop      = this.onDrop.bind(this);
  }

  connectedCallback() {
    // Initialer State aus Light DOM
    this.items = Array.from(this.children).map((child, index) => ({
      id: String(index),
      content: child.innerHTML
    }));
    // Light DOM leeren (Inhalt wird im Shadow DOM gerendert)
    this.innerHTML = '';

    this.render();
    this.addEventListeners();
  }

  addEventListeners() {
    this.shadowRoot.addEventListener('dragstart', this.onDragStart);
    this.shadowRoot.addEventListener('dragenter', this.onDragEnter);
    this.shadowRoot.addEventListener('dragover', this.onDragOver);
    this.shadowRoot.addEventListener('dragleave', this.onDragLeave);
    this.shadowRoot.addEventListener('drop', this.onDrop);
    this.shadowRoot.addEventListener('dragend', this.onDragEnd);
  }

  onDragStart(e) {
    const target = e.target.closest('.sortable-item');
    if (!target) return;
    this.draggedItemId = target.getAttribute('data-id');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text', this.draggedItemId);

    // Klasse "dragging" wird später im Render-Prozess gesetzt
    this.render();
  }

  onDragEnter(e) {
    e.preventDefault();
  }

  onDragOver(e) {
    e.preventDefault();
    const target = e.target.closest('.sortable-item');
    if (!target || target.getAttribute('data-id') === this.draggedItemId) {
      return;
    }

    const bounding = target.getBoundingClientRect();
    const offset = e.clientY - bounding.top;
    const isAfter = offset > bounding.height / 2;
    const targetIndex = this.indexOfItem(target.getAttribute('data-id'));
    this.dragOverIndex = isAfter ? targetIndex + 1 : targetIndex;

    this.render();
  }

  onDragLeave(e) {
    // Wenn der Mauszeiger das Container-Element verlässt, kann der Indikator zurückgesetzt werden,
    // aber nur, wenn nicht auf ein anderes Element übergegangen wird.
    if (e.relatedTarget === null || !this.shadowRoot.contains(e.relatedTarget)) {
      this.dragOverIndex = null;
      this.render();
    }
  }

  onDrop(e) {
    e.stopPropagation();
    const draggedId = e.dataTransfer.getData('text');
    const fromIndex = this.indexOfItem(draggedId);
    let toIndex = this.dragOverIndex !== null ? this.dragOverIndex : this.items.length;
    
    if (toIndex > this.items.length) toIndex = this.items.length;

    if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {
      const [moved] = this.items.splice(fromIndex, 1);
      this.items.splice(toIndex, 0, moved);
    }

    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  onDragEnd(e) {
    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  indexOfItem(id) {
    return this.items.findIndex(i => i.id === id);
  }

  render() {
    const styles = `
      :host {
        display: block;
        border: 1px solid #ccc;
        padding: 0.5rem;
        background: #ffffff;
        font-family: sans-serif;
      }
      .sortable-item {
        user-select: none;
        background: #f9f9f9;
        margin: 0.25rem 0;
        padding: 0.5rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        cursor: move;
        transition: background 0.2s, opacity 0.2s;
      }
      .sortable-item.dragging {
        opacity: 0.5;
        background: #ffe5b4;
      }
      .drop-indicator {
        height: 0;
        border-top: 2px dashed #888;
        margin: 0.4rem 0;
      }
    `;

    // Wir erstellen den HTML-Inhalt komplett aus dem State (items)
    // So vermeiden wir direkte manuelle DOM-Manipulation wie replaceWith etc.
    let html = `<style>${styles}</style><div id="container">`;

    this.items.forEach((item, index) => {
      if (this.dragOverIndex === index) {
        html += `<div class="drop-indicator"></div>`;
      }

      const draggingClass = (this.draggedItemId === item.id) ? ' dragging' : '';
      html += `<div class="sortable-item${draggingClass}" draggable="true" data-id="${item.id}">${item.content}</div>`;
    });

    if (this.dragOverIndex === this.items.length) {
      html += `<div class="drop-indicator"></div>`;
    }

    html += `</div>`;

    this.shadowRoot.innerHTML = html;
  }
}

customElements.define('sortable-list', SortableList);
</script>

<!-- Beispiel-Nutzung -->
<sortable-list>
  <div>Element A</div>
  <div>Element B</div>
  <div>Element C</div>
  <div>Element D</div>
</sortable-list>

</body>
</html>
