<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Sortable Webcomponent</title>
</head>
<body>

<script>
// Einfache Touch-Drag&Drop-Polyfill
(function() {
  const isTouchDevice = 'ontouchstart' in window;
  if (!isTouchDevice) return;

  let draggedEl = null;
  let currentDropTarget = null;

  document.addEventListener('touchstart', (e) => {
    const target = e.target.closest('[draggable="true"]');
    if (target) {
      draggedEl = target;
      target.classList.add('dragging');
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchmove', (e) => {
    if (draggedEl) {
      const elem = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY);
      if (elem) {
        let dropTarget = elem.closest('[draggable="true"]');
        if (dropTarget && dropTarget !== draggedEl) {
          currentDropTarget = dropTarget;
        }
      }
      e.preventDefault();
    }
  }, {passive:false});

  document.addEventListener('touchend', (e) => {
    if (draggedEl) {
      draggedEl.classList.remove('dragging');
      if (currentDropTarget && currentDropTarget.parentNode) {
        const dropEvent = new Event('drop', {bubbles: true});
        // Da dataTransfer unter Touch nicht existiert, simulieren wir es
        dropEvent.dataTransfer = { getData: () => draggedEl.getAttribute('data-id') };
        currentDropTarget.dispatchEvent(dropEvent);
      }
      draggedEl = null;
      currentDropTarget = null;
      e.preventDefault();
    }
  }, {passive:false});
})();

// Custom Element f√ºr sortierbare Liste
class SortableList extends HTMLElement {
  static get template() {
    return `
      <style>
        :host {
          display: block;
          border: 1px solid #ccc;
          padding: 0.5rem;
          background: #ffffff;
          font-family: sans-serif;
          position: relative;
        }
        .sortable-item {
          user-select: none;
          background: #f9f9f9;
          margin: 0.25rem 0;
          padding: 0.5rem;
          border: 1px solid #ddd;
          border-radius: 4px;
          cursor: move;
          transition: background 0.2s, opacity 0.2s;
          display: block;
        }
        .sortable-item.dragging {
          opacity: 0.5;
          background: #ffe5b4;
        }
        .drop-indicator {
          height: 0;
          border-top: 2px dashed #888;
          margin: 0.4rem 0;
        }
        #container {
          display: block;
        }
        ::slotted(*) {
          display: none;
        }
      </style>
      <div id="container"></div>
      <slot></slot>
    `;
  }

  constructor() {
    super();
    this.attachShadow({mode:'open'});
    this.items = [];
    this.draggedItemId = null;
    this.dragOverIndex = null;

    this.onDragStart = this.onDragStart.bind(this);
    this.onDragEnd   = this.onDragEnd.bind(this);
    this.onDragEnter = this.onDragEnter.bind(this);
    this.onDragOver  = this.onDragOver.bind(this);
    this.onDragLeave = this.onDragLeave.bind(this);
    this.onDrop      = this.onDrop.bind(this);
    this.onSlotChange= this.onSlotChange.bind(this);
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = this.constructor.template;
    const slot = this.shadowRoot.querySelector('slot');
    slot.addEventListener('slotchange', this.onSlotChange);

    this.shadowRoot.addEventListener('dragstart', this.onDragStart);
    this.shadowRoot.addEventListener('dragenter', this.onDragEnter);
    this.shadowRoot.addEventListener('dragover', this.onDragOver);
    this.shadowRoot.addEventListener('dragleave', this.onDragLeave);
    this.shadowRoot.addEventListener('drop', this.onDrop);
    this.shadowRoot.addEventListener('dragend', this.onDragEnd);

    // Initialer Render nach Slot-Update
    Promise.resolve().then(() => this.onSlotChange());
  }

  onSlotChange() {
    const slot = this.shadowRoot.querySelector('slot');
    const assigned = slot.assignedElements({flatten:true});
    this.items = assigned.map((child, index) => ({
      id: String(index),
      content: child.innerHTML.trim()
    }));
    this.render();
  }

  indexOfItem(id) {
    return this.items.findIndex(i => i.id === id);
  }

  onDragStart(e) {
    const target = e.target.closest('.sortable-item');
    if (!target) return;
    this.draggedItemId = target.getAttribute('data-id');
    e.dataTransfer.effectAllowed = 'move';
    // Wichtig: 'text/plain' verwenden damit es standardkonform ist
    e.dataTransfer.setData('text/plain', this.draggedItemId);
    this.render();
  }

  onDragEnter(e) {
    // Ohne preventDefault kann kein Drop erfolgen
    e.preventDefault();
  }

  onDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const target = e.target.closest('.sortable-item');
    if (!target || target.getAttribute('data-id') === this.draggedItemId) return;

    const rect = target.getBoundingClientRect();
    const offset = e.clientY - rect.top;
    const isAfter = offset > (rect.height / 2);
    const targetIndex = this.indexOfItem(target.getAttribute('data-id'));
    this.dragOverIndex = isAfter ? targetIndex + 1 : targetIndex;

    this.render();
  }

  onDragLeave(e) {
    if (!e.relatedTarget || !this.shadowRoot.contains(e.relatedTarget)) {
      this.dragOverIndex = null;
      this.render();
    }
  }

  onDrop(e) {
    e.preventDefault();
    const draggedId = e.dataTransfer.getData('text/plain');
    const fromIndex = this.indexOfItem(draggedId);
    let toIndex = this.dragOverIndex !== null ? this.dragOverIndex : this.items.length;

    if (toIndex > this.items.length) {
      toIndex = this.items.length;
    }

    if (fromIndex !== -1 && toIndex !== -1 && fromIndex !== toIndex) {
      const [moved] = this.items.splice(fromIndex, 1);
      this.items.splice(toIndex, 0, moved);
    }

    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  onDragEnd() {
    this.draggedItemId = null;
    this.dragOverIndex = null;
    this.render();
  }

  render() {
    const container = this.shadowRoot.querySelector('#container');
    if (!container) return;

    let itemsHtml = '';
    this.items.forEach((item, index) => {
      if (this.dragOverIndex === index) {
        itemsHtml += `<div class="drop-indicator"></div>`;
      }
      const draggingClass = (this.draggedItemId === item.id) ? ' dragging' : '';
      itemsHtml += `<div class="sortable-item${draggingClass}" draggable="true" data-id="${item.id}">${item.content}</div>`;
    });

    if (this.dragOverIndex === this.items.length) {
      itemsHtml += `<div class="drop-indicator"></div>`;
    }

    container.innerHTML = itemsHtml;
  }
}

customElements.define('sortable-list', SortableList);
</script>

<!-- Beispiel -->
<sortable-list>
  <div>Element A</div>
  <div>Element B</div>
  <div>Element C</div>
  <div>Element D</div>
</sortable-list>

</body>
</html>
