<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Sortable Web Component</title>
<style>
  /* Globale Styles für Demo-Zwecke */
  body {
    font-family: sans-serif;
    margin: 20px;
  }
  
  sortable-container {
    display: block;
    margin-bottom: 20px;
  }
</style>
</head>
<body>

<!-- Polyfill für mobile Drag & Drop (Beispiel-Polyfill; bitte ggf. anpassen)
     Da keine externen Bibliotheken erlaubt sind, wird hier ein bekannter 
     minimaler Polyfill inline eingefügt. In der Praxis würde man hier 
     einen geprüften Polyfill einbinden. -->
<script>
/*!
 * Einfaches Drag & Drop Polyfill für Touchgeräte (Beispiel)
 * Quelle: adaptierter Code von diversen Open-Source Snippets
 * Hinweis: Dies ist eine vereinfachte Version und dient nur als Beispiel.
 */
(function(){
  var isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if(!isTouch) return;
  
  var _startX, _startY, _dragEl, _dataTransfer;
  
  function touchHandler(event) {
    var firstTouch = event.changedTouches[0];
    var type = "";
    switch(event.type) {
      case "touchstart": type = "mousedown"; break;
      case "touchmove": type = "mousemove"; break;        
      case "touchend": type = "mouseup"; break;
      default: return;
    }

    var simulatedEvent = document.createEvent("MouseEvent");
    simulatedEvent.initMouseEvent(
      type, true, true, window, 1, 
      firstTouch.screenX, firstTouch.screenY, 
      firstTouch.clientX, firstTouch.clientY, 
      false, false, false, false, 0, null
    );
    firstTouch.target.dispatchEvent(simulatedEvent);
    event.preventDefault();
  }
  
  document.addEventListener("touchstart", touchHandler, true);
  document.addEventListener("touchmove", touchHandler, true);
  document.addEventListener("touchend", touchHandler, true);
  document.addEventListener("touchcancel", touchHandler, true);
})();
</script>

<template id="sortable-container-template">
  <style>
    :host {
      display: block;
      border: 1px solid #ccc;
      padding: 10px;
      position: relative;
      user-select: none;
    }

    .item {
      padding: 8px;
      margin-bottom: 5px;
      background: #eee;
      cursor: move;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .item.dragging {
      opacity: 0.5;
      background: #ccc;
    }

    /* Hervorhebung der Drop-Position */
    .item.drop-target {
      border-top: 2px solid blue;
    }
  </style>
  <div id="container"></div>
</template>

<script>
class SortableContainer extends HTMLElement {
  constructor() {
    super();
    this._items = [];
    this._draggedIndex = null;
    this._dropTargetIndex = null;
    this._shadow = this.attachShadow({ mode: 'open' });

    // Template klonen
    const template = document.getElementById('sortable-container-template');
    this._shadow.appendChild(template.content.cloneNode(true));

    // Referenzen
    this._container = this._shadow.querySelector('#container');
  }

  connectedCallback() {
    // Initialisiere Daten von Light DOM Kindern (direkt innerhalb des Elements)
    // Wir nehmen an, dass jedes Kind ein sortierbares Element repräsentiert.
    // Wir binden nur den Textinhalt. Komplexer könnte man auch mehr übernehmen.
    const lightChildren = Array.from(this.children);
    this._items = lightChildren.map((child) => child.textContent.trim());

    // Ursprüngliche Kinder entfernen, da wir intern rendern
    // (Die Items werden in der ShadowDOM gerendert)
    while (this.firstChild) {
      this.removeChild(this.firstChild);
    }

    this.render();
    this.addEventListeners();
  }

  addEventListeners() {
    // Ereignisse auf Container-Ebene behandeln
    this._container.addEventListener('dragstart', this.onDragStart.bind(this));
    this._container.addEventListener('dragend', this.onDragEnd.bind(this));
    this._container.addEventListener('dragover', this.onDragOver.bind(this));
    this._container.addEventListener('dragleave', this.onDragLeave.bind(this));
    this._container.addEventListener('drop', this.onDrop.bind(this));
  }

  // "Render"-Funktion, die auf Basis von this._items die Anzeige aktualisiert.
  // Hier verwenden wir eine Art von Datenbindung durch komplettes Neurendern,
  // um direkte manuelle DOM-Manipulationen zu minimieren.
  render() {
    // Komplett neu aufbauen
    let html = '';
    this._items.forEach((itemText, index) => {
      html += `<div class="item" draggable="true" data-index="${index}">${itemText}</div>`;
    });
    this._container.innerHTML = html;
    this.highlightDraggedAndTarget();
  }

  highlightDraggedAndTarget() {
    const items = this._shadow.querySelectorAll('.item');
    items.forEach((el) => {
      el.classList.remove('dragging', 'drop-target');
    });
    if (this._draggedIndex !== null && items[this._draggedIndex]) {
      items[this._draggedIndex].classList.add('dragging');
    }
    if (this._dropTargetIndex !== null && items[this._dropTargetIndex]) {
      items[this._dropTargetIndex].classList.add('drop-target');
    }
  }

  onDragStart(e) {
    const target = e.target.closest('.item');
    if (!target) return;
    this._draggedIndex = parseInt(target.dataset.index, 10);
    e.dataTransfer.effectAllowed = 'move';
    // IE-/Edge-Kompatibilität
    e.dataTransfer.setData('text/plain', this._draggedIndex.toString());
    this.render();
  }

  onDragEnd(e) {
    this._draggedIndex = null;
    this._dropTargetIndex = null;
    this.render();
  }

  onDragOver(e) {
    e.preventDefault();
    const target = e.target.closest('.item');
    if (!target) return;
    const overIndex = parseInt(target.dataset.index, 10);
    if (overIndex !== this._draggedIndex) {
      this._dropTargetIndex = overIndex;
      this.highlightDraggedAndTarget();
    }
  }

  onDragLeave(e) {
    const target = e.target.closest('.item');
    if (!target) return;
    // Wenn wir den Container verlassen, Drop-Target entfernen
    if (e.relatedTarget && !this._container.contains(e.relatedTarget)) {
      this._dropTargetIndex = null;
      this.highlightDraggedAndTarget();
    }
  }

  onDrop(e) {
    e.preventDefault();
    let draggedIndex = this._draggedIndex;
    if (draggedIndex === null) {
      draggedIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
    }

    const target = e.target.closest('.item');
    if (!target) return;

    const dropIndex = parseInt(target.dataset.index, 10);

    // Neu anordnen
    if (draggedIndex !== null && dropIndex !== null && draggedIndex !== dropIndex) {
      const item = this._items.splice(draggedIndex, 1)[0];
      // Einfügen vor/bei der Drop-Position
      const insertPos = dropIndex < draggedIndex ? dropIndex : dropIndex;
      this._items.splice(insertPos, 0, item);
    }

    this._draggedIndex = null;
    this._dropTargetIndex = null;
    this.render();
  }
}

customElements.define('sortable-container', SortableContainer);
</script>

<sortable-container>
  <div>Erstes Element</div>
  <div>Zweites Element</div>
  <div>Drittes Element</div>
  <div>Viertes Element</div>
  <div>Fünftes Element</div>
</sortable-container>

</body>
</html>
