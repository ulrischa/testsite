<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Drag-and-Drop mit optischem Schieben</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 1rem;
    }
  </style>
</head>
<body>
  <sortable-list>
    <div>Element 1</div>
    <div>Element 2</div>
    <div>Element 3</div>
    <div>Element 4</div>
    <div>Element 5</div>
  </sortable-list>

  <script>
    class SortableList extends HTMLElement {
      items = [];           // Datenquelle
      draggedIndex = null;  // Index des gezogenen Elements
      targetIndex = null;   // Zielposition des Elements
      currentY = 0;

      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.initializeItems();
        this.render();
      }

      /** Initialisiere die Datenquelle */
      initializeItems() {
        this.items = Array.from(this.children).map((child) => child.outerHTML.trim());
      }

      /** Rendert die Liste basierend auf der Datenquelle */
      render() {
        this.shadowRoot.innerHTML = `
          <style>
            .item {
              padding: 10px;
              margin: 4px 0;
              background: #f3f3f3;
              border: 1px solid #ccc;
              border-radius: 4px;
              cursor: grab;
              user-select: none;
              transition: transform 0.2s ease;
            }
            .dragging {
              opacity: 0.5;
              z-index: 1000;
              cursor: grabbing;
              position: relative;
            }
            .shifted {
              transform: translateY(40px);
            }
            .shifted-up {
              transform: translateY(-40px);
            }
          </style>
          ${this.items
            .map(
              (content, index) =>
                `<div class="item ${this.getShiftClass(index)}" draggable="true" data-index="${index}">
                  ${content}
                </div>`
            )
            .join("")}
        `;
        this.addEventListeners();
      }

      /** Ermittelt die Klasse für visuelles Verschieben */
      getShiftClass(index) {
        if (this.draggedIndex === null || this.targetIndex === null) return "";
        if (index === this.targetIndex) return "shifted"; // Platz für das gezogene Element
        if (this.draggedIndex < this.targetIndex && index > this.draggedIndex && index <= this.targetIndex)
          return "shifted-up";
        if (this.draggedIndex > this.targetIndex && index >= this.targetIndex && index < this.draggedIndex)
          return "shifted";
        return "";
      }

      /** Fügt Event-Handler hinzu */
      addEventListeners() {
        const items = this.shadowRoot.querySelectorAll(".item");
        items.forEach((item) => {
          item.addEventListener("dragstart", (e) => this.onDragStart(e, item));
          item.addEventListener("dragover", (e) => this.onDragOver(e, item));
          item.addEventListener("drop", () => this.onDrop());
          item.addEventListener("touchstart", (e) => this.onTouchStart(e, item), { passive: false });
          item.addEventListener("touchmove", (e) => this.onTouchMove(e), { passive: false });
          item.addEventListener("touchend", () => this.onTouchEnd());
        });
      }

      /** Drag-Start */
      onDragStart(event, item) {
        this.draggedIndex = parseInt(item.dataset.index);
        this.targetIndex = this.draggedIndex;
        item.classList.add("dragging");
        this.render();
      }

      /** Drag-Over */
      onDragOver(event, target) {
        event.preventDefault();
        const targetIndex = parseInt(target.dataset.index);
        if (targetIndex !== this.targetIndex) {
          this.targetIndex = targetIndex;
          this.render();
        }
      }

      /** Drop */
      onDrop() {
        this.updateOrder();
      }

      /** Touch-Start */
      onTouchStart(event, item) {
        event.preventDefault();
        this.draggedIndex = parseInt(item.dataset.index);
        this.targetIndex = this.draggedIndex;
        this.currentY = event.touches[0].clientY;
        item.classList.add("dragging");
      }

      /** Touch-Move */
      onTouchMove(event) {
        event.preventDefault();
        const deltaY = event.touches[0].clientY - this.currentY;
        this.currentY = event.touches[0].clientY;

        const items = Array.from(this.shadowRoot.querySelectorAll(".item"));
        items.forEach((el, index) => {
          const rect = el.getBoundingClientRect();
          if (this.currentY > rect.top && this.currentY < rect.bottom) {
            this.targetIndex = index;
          }
        });
        this.render();
      }

      /** Touch-End */
      onTouchEnd() {
        this.updateOrder();
      }

      /** Aktualisiere die Reihenfolge */
      updateOrder() {
        if (this.draggedIndex !== null && this.targetIndex !== null && this.draggedIndex !== this.targetIndex) {
          const [movedItem] = this.items.splice(this.draggedIndex, 1);
          this.items.splice(this.targetIndex, 0, movedItem);
        }
        this.draggedIndex = null;
        this.targetIndex = null;
        this.render();
      }
    }

    customElements.define("sortable-list", SortableList);
  </script>
</body>
</html>
