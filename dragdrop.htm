<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Sortierbare Liste mit Desktop und Mobile Support</title>
</head>
<body>
  <!-- Sortable List -->
  <sortable-list>
    <div>Element 1</div>
    <div>Element 2</div>
    <div>Element 3</div>
    <div>Element 4</div>
  </sortable-list>

  <script>
    class SortableList extends HTMLElement {
      items = [];        // Liste der Elemente
      draggedItem = null; // Aktuelles Element bei Drag oder Touch
      startY = 0;        // Startposition des Touches
      offsetY = 0;       // Offset f체r die visuelle Bewegung

      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }

      connectedCallback() {
        this.initializeItems();
        this.render();
      }

      initializeItems() {
        this.items = Array.from(this.children);
      }

      render() {
        this.shadowRoot.innerHTML = `
          <style>
            ::slotted(*) {
              padding: 10px;
              margin: 4px 0;
              background: #f3f3f3;
              border: 1px solid #ccc;
              border-radius: 4px;
              cursor: move;
              user-select: none;
              transition: transform 0.1s ease;
            }
            .dragging {
              opacity: 0.7;
              z-index: 1000;
            }
          </style>
          <slot></slot>
        `;

        this.items.forEach((item) => {
          item.draggable = true; // F체r Desktop-Drag-and-Drop

          // Desktop-Events
          item.addEventListener("dragstart", () => this.onDragStart(item));
          item.addEventListener("dragover", (e) => e.preventDefault());
          item.addEventListener("drop", () => this.onDrop(item));

          // Touch-Events f체r Mobile Ger채te
          item.addEventListener("touchstart", (e) => this.onTouchStart(e, item));
          item.addEventListener("touchmove", (e) => this.onTouchMove(e));
          item.addEventListener("touchend", () => this.onTouchEnd());
        });
      }

      /** Desktop-Drag-and-Drop */
      onDragStart(item) {
        this.draggedItem = item;
        item.classList.add("dragging");
      }

      onDrop(target) {
        if (this.draggedItem && this.draggedItem !== target) {
          // Tausche die Position der Elemente
          const draggedIndex = this.items.indexOf(this.draggedItem);
          const targetIndex = this.items.indexOf(target);

          [this.items[draggedIndex], this.items[targetIndex]] =
            [this.items[targetIndex], this.items[draggedIndex]];

          this.reorderItems();
        }
        this.reset();
      }

      /** Touch-Events */
      onTouchStart(event, item) {
        this.draggedItem = item;
        this.startY = event.touches[0].clientY;
        this.offsetY = 0;
        item.classList.add("dragging");
        event.preventDefault();
      }

      onTouchMove(event) {
        if (!this.draggedItem) return;

        const currentY = event.touches[0].clientY;
        this.offsetY = currentY - this.startY;

        // Visuelles Bewegen des Elements
        this.draggedItem.style.transform = `translateY(${this.offsetY}px)`;

        // Ziel-Element unter dem Finger erkennen
        const target = document.elementFromPoint(event.touches[0].clientX, currentY);
        if (target && target !== this.draggedItem && this.contains(target)) {
          const targetIndex = this.items.indexOf(target);
          const draggedIndex = this.items.indexOf(this.draggedItem);

          if (targetIndex !== -1 && draggedIndex !== targetIndex) {
            [this.items[draggedIndex], this.items[targetIndex]] =
              [this.items[targetIndex], this.items[draggedIndex]];

            this.reorderItems();
            this.startY = currentY; // Aktualisiere die Startposition
          }
        }
      }

      onTouchEnd() {
        if (this.draggedItem) {
          this.draggedItem.style.transform = "";
          this.reset();
        }
      }

      /** Aktualisiere die Reihenfolge der Elemente im DOM */
      reorderItems() {
        this.items.forEach((item) => this.appendChild(item));
      }

      reset() {
        if (this.draggedItem) {
          this.draggedItem.classList.remove("dragging");
          this.draggedItem = null;
        }
      }
    }

    customElements.define("sortable-list", SortableList);
  </script>
</body>
</html>
