<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<title>Drag & Drop Web Component</title>
<style>
  :host {
    display: block;
    position: relative;
    font-family: sans-serif;
  }

  .container {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .item {
    background: #fff;
    border: 1px solid #ccc;
    padding: 0.5rem;
    cursor: move;
    user-select: none;
    transition: background-color 0.2s, box-shadow 0.2s;
  }

  .item.dragging {
    opacity: 0.8;
    background-color: #f0f0f0;
    box-shadow: 0 0 8px rgba(0,0,0,0.2);
  }

  .placeholder {
    background: #ddeeff;
    border: 1px dashed #88aaff;
    min-height: 2rem;
    transition: background-color 0.2s;
  }
</style>
</head>
<body>

<!-- Polyfill für Touch-Drag & Drop (Minimal) -->
<!-- Hinweis: Dies ist ein sehr vereinfachtes Polyfill, um DnD Events über Touch auszulösen -->
<script>
  (function() {
    let touchSource = null;

    document.addEventListener('touchstart', e => {
      const target = e.target.closest('[draggable="true"]');
      if (target) {
        touchSource = target;
        const dragStartEvent = new Event('dragstart', { bubbles: true, cancelable: true });
        target.dispatchEvent(dragStartEvent);
      }
    }, { passive: true });

    document.addEventListener('touchmove', e => {
      if (touchSource) {
        e.preventDefault();
        const dragEvent = new Event('dragover', { bubbles: true, cancelable: true });
        touchSource.dispatchEvent(dragEvent);
      }
    }, { passive: false });

    document.addEventListener('touchend', e => {
      if (touchSource) {
        const dropEvent = new Event('drop', { bubbles: true, cancelable: true });
        touchSource.dispatchEvent(dropEvent);
        const dragEndEvent = new Event('dragend', { bubbles: true, cancelable: true });
        touchSource.dispatchEvent(dragEndEvent);
        touchSource = null;
      }
    });
  })();
</script>

<template id="sortable-template">
  <div class="container">
    <!-- Items werden hier gerendert -->
  </div>
</template>

<script>
  class SortableList extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: 'open' });
      // Internes State-Array für die Items
      this._items = [];
      this._draggedIndex = null;
      this._dragOverIndex = null;
    }

    static get observedAttributes() {
      return ['items'];
    }

    attributeChangedCallback(name, oldVal, newVal) {
      if (name === 'items') {
        try {
          this._items = JSON.parse(newVal);
        } catch (e) {
          this._items = [];
        }
        this.render();
      }
    }

    // Getter und Setter für Items
    get items() {
      return this._items;
    }

    set items(value) {
      if (Array.isArray(value)) {
        this._items = value;
        this.render();
      }
    }

    connectedCallback() {
      // Falls keine Items gesetzt wurden
      if (!this.hasAttribute('items')) {
        // Prüfe ob es bereits Kinder gibt, dann auslesen
        const initialItems = Array.from(this.children).map(el => el.textContent.trim());
        this.items = initialItems;
      } else {
        // Items bereits über Attribut
        try {
          this._items = JSON.parse(this.getAttribute('items'));
        } catch(e) {
          this._items = [];
        }
      }

      this.render();

      // Event Listener für Drag and Drop
      this.shadowRoot.addEventListener('dragstart', this._onDragStart.bind(this));
      this.shadowRoot.addEventListener('dragend', this._onDragEnd.bind(this));
      this.shadowRoot.addEventListener('dragover', this._onDragOver.bind(this));
      this.shadowRoot.addEventListener('drop', this._onDrop.bind(this));
    }

    // Data-Binding / Render Logik: komplette Neu-Render des Inhalts
    // Keine direkte DOM-Manipulation per Hand, sondern vollständiges Re-Rendering
    render() {
      const template = document.getElementById('sortable-template');
      const content = template.content.cloneNode(true);

      const container = content.querySelector('.container');
      
      // Falls ein Drag-Over stattfindet, wollen wir eine Platzhalter-Position einfügen
      // items werden neu gemapped unter Berücksichtigung des Platzhalters.
      let renderedItems = [...this._items];

      // Wenn wir gerade über ein Element hovern, fügen wir an dieser Stelle eine Placeholder-Div ein.
      if (this._dragOverIndex !== null && this._dragOverIndex >= 0) {
        renderedItems = [
          ...renderedItems.slice(0, this._dragOverIndex),
          { placeholder: true },
          ...renderedItems.slice(this._dragOverIndex)
        ];
      }

      renderedItems.forEach((item, index) => {
        if (item.placeholder) {
          const placeholderEl = document.createElement('div');
          placeholderEl.className = 'placeholder';
          container.appendChild(placeholderEl);
        } else {
          const div = document.createElement('div');
          div.className = 'item';
          div.setAttribute('draggable', 'true');
          div.textContent = item;
          // Wenn dieses Element gerade gezogen wird
          if (this._draggedIndex !== null && this._draggedIndex !== undefined && !item.placeholder && this._items[this._draggedIndex] === item) {
            div.classList.add('dragging');
          }
          container.appendChild(div);
        }
      });

      // ShadowRoot wird neu gesetzt
      this.shadowRoot.innerHTML = '';
      this.shadowRoot.appendChild(content);
    }

    _onDragStart(e) {
      // Finde den Index des Elements
      const itemEl = e.target.closest('.item');
      if (!itemEl) return;
      this._draggedIndex = this._getItemIndexFromEvent(e);
      e.dataTransfer.effectAllowed = 'move';
      // Nur für Desktop DnD: leeres Image als Drag-Image, um die Darstellung zu steuern
      const img = document.createElement('img');
      img.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4////fyYGBgYGJ1BAB/4CIIYGByBgAAAABJRU5ErkJggg==';
      e.dataTransfer.setDragImage(img, 0, 0); 
      this.render();
    }

    _onDragEnd(e) {
      this._draggedIndex = null;
      this._dragOverIndex = null;
      this.render();
      // Hier könnte ein Custom-Event abgesetzt werden, um das neue Items-Array anzuzeigen
      this.dispatchEvent(new CustomEvent('items-changed', { detail: { items: this._items } }));
    }

    _onDragOver(e) {
      e.preventDefault();
      const overIndex = this._getItemIndexFromEvent(e, true);
      if (overIndex !== this._dragOverIndex) {
        this._dragOverIndex = overIndex;
        this.render();
      }
    }

    _onDrop(e) {
      e.preventDefault();
      const dropIndex = this._dragOverIndex === null ? this._items.length : this._dragOverIndex;
      if (this._draggedIndex !== null && dropIndex !== null) {
        // Element neu anordnen
        const draggedItem = this._items[this._draggedIndex];
        const newItems = [...this._items];
        // Altes Element entfernen
        newItems.splice(this._draggedIndex, 1);
        // An neuer Stelle einfügen
        // Wenn dropIndex > length, auf length begrenzen
        const insertIndex = Math.min(dropIndex, newItems.length);
        newItems.splice(insertIndex, 0, draggedItem);
        this._items = newItems;
      }
      this._draggedIndex = null;
      this._dragOverIndex = null;
      this.render();
      this.dispatchEvent(new CustomEvent('items-changed', { detail: { items: this._items } }));
    }

    _getItemIndexFromEvent(e, includePlaceholder = false) {
      const container = this.shadowRoot.querySelector('.container');
      const children = Array.from(container.children);
      const targetEl = e.target.closest('.item, .placeholder');
      if (!targetEl) {
        // Falls wir nicht über einem item oder placeholder sind, Position am Ende
        return children.filter(ch => ch.classList.contains('item') || ch.classList.contains('placeholder')).length;
      }

      // Index ermitteln
      let filtered = children.filter(ch => ch.classList.contains('item') || ch.classList.contains('placeholder'));
      let index = filtered.indexOf(targetEl);
      if (!includePlaceholder) {
        // Wenn wir den Index im "echten" Array brauchen,
        // dann müssen wir Placeholder ignorieren
        // Placeholder zählt nicht als echtes Item
        // Wir können den Placeholder aber nutzen, um die finale Position abzuleiten
        if (targetEl.classList.contains('placeholder')) {
          // Der Placeholder repräsentiert den dropIndex
          return index;
        } else {
          // Item-Index ermitteln ohne Placeholder
          const placeholderCountBefore = filtered.slice(0, index).filter(ch => ch.classList.contains('placeholder')).length;
          return index - placeholderCountBefore;
        }
      } else {
        // Hier wollen wir die Stelle für Drop bestimmen (inkl. Placeholder)
        return index;
      }
    }
  }

  customElements.define('sortable-list', SortableList);
</script>

<sortable-list items='["Erstes Element", "Zweites Element", "Drittes Element", "Viertes Element"]'></sortable-list>
</body>
</html>
